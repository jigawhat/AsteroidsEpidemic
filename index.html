<html>
<head>
<style>
body {
    text-align: center;
}
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()">
<!-- <center> -->
<!-- <canvas id="myCanvas" width="800" height="600" style="border:1px solid #000000;">
</canvas> -->

<!-- <script>
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
ctx.moveTo(0, 0);
ctx.lineTo(200, 100);
ctx.stroke();
</script> -->

<script>


// Constants

const WIDTH = 800;
const HEIGHT = 600;
const DOUGHNUT_MARGIN = 50;                  // Margin for doughnut-shaped universe looping
const FRAMERATE = 50;                        // Game framerate
const SHIP_SPEED = 0.1;
const SHIP_TURN_SPEED = 7.5;
const SAFE_SPAWN_DISTANCE = 150;             // Minimum distance from ship to asteroid spawn
const MISSILE_SPEED = 8.5;
const MISSILE_LENGTH = 15;
const MISSILE_LIFESPAN = 75;                 // Missile lifespan in frames
const ASTEROID_NUM_POINTS = 16;   
const SMALL_ASTEROID_RADIUS = 20;
const MEDIUM_ASTEROID_RADIUS = 37;
const LARGE_ASTEROID_RADIUS = 55;
const ASTEROID_ROTATE_SPEED = 0.005;
const ASTEROID_SPEED = 1.0;
const ASTEROID_MAXAGE = 7.0;                 // Maximum possible age before evolution
const ASTEROID_EVOLUTION_TIMER = 2.1;
const SMALL_ASTEROID_SPEED_MULTIPLIER = 2.0;
const MEDIUM_ASTEROID_SPEED_MULTIPLIER = 1.4;



// Variables

var ship;
var missiles = [];
var asteroids = [];
var firing = false;


// Initialise game
function startGame() {
  myGameArea.start();
  ship = new Ship(10, 120);
  test_asteroid = new Asteroid("SMALL", null, null);
  asteroids.push(test_asteroid);
}

var myGameArea = {
  canvas : document.createElement("canvas"),
  start : function() {

    // Setup canvas
    this.canvas.width = WIDTH;
    this.canvas.height = HEIGHT;
    this.context = this.canvas.getContext("2d");
    document.body.insertBefore(this.canvas, document.body.childNodes[0]);

    // Setup frames
    this.interval = setInterval(updateGameArea, 1000 / FRAMERATE);

    // Add keyboard listeners
    window.addEventListener('keydown', function (e) {
      myGameArea.keys = (myGameArea.keys || []);
      myGameArea.keys[e.keyCode] = true;
      // alert("Key " + e.keyCode + " pressed.");
    })
    window.addEventListener('keyup', function (e) {
      myGameArea.keys[e.keyCode] = false;
    })
  },

  // Refresh screen
  clear : function() {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
}

// Abstract class for game objects to loop
class MovingObject {
  constructor(x, y) {
    this.speedX = 0;
    this.speedY = 0;
    this.angle = 0;
    this.moveAngle = 0;  // Angular speed
    this.x = x;
    this.y = y;
  }
  newPos() {
    // Update angle and position
    this.angle += this.moveAngle;
    var new_x = this.x + this.speedX;
    var new_y = this.y + this.speedY;

    // Doughnut-shaped universe implementation
    if (new_x < -DOUGHNUT_MARGIN) {
      new_x = WIDTH + DOUGHNUT_MARGIN
    } else if (new_x > WIDTH + DOUGHNUT_MARGIN) {
      new_x = -DOUGHNUT_MARGIN
    }
    if (new_y < -DOUGHNUT_MARGIN) {
      new_y = HEIGHT + DOUGHNUT_MARGIN
    } else if (new_y > HEIGHT + DOUGHNUT_MARGIN) {
      new_y = -DOUGHNUT_MARGIN
    }
    this.x = new_x;
    this.y = new_y;
  }
}

// Asteroid class
const angle_incr = 2 * Math.PI / ASTEROID_NUM_POINTS;
class Asteroid extends MovingObject {
  constructor(state, x, y) {
    if (x == null) {
      // Spawn the asteroid a safe distance from the ship
      var x = Math.random() * WIDTH;
      var y = Math.random() * HEIGHT;
      while (ship && distance(x, y, ship.x, ship.y) < SAFE_SPAWN_DISTANCE) {
        x = Math.random() * WIDTH;
        y = Math.random() * HEIGHT;
      }
    }
    super(x, y);
    this.state = state;
    this.radius = LARGE_ASTEROID_RADIUS;
    var speed_multiplier = 1.0;
    if (state == "MEDIUM") {
      this.radius = MEDIUM_ASTEROID_RADIUS;
      speed_multiplier = MEDIUM_ASTEROID_SPEED_MULTIPLIER;
      this.framesTilEvolution = (Math.random() * (ASTEROID_MAXAGE * FRAMERATE)) + 2;
    } else if (state == "SMALL") {
      this.radius = SMALL_ASTEROID_RADIUS;
      speed_multiplier = SMALL_ASTEROID_SPEED_MULTIPLIER;
      this.framesTilEvolution = (Math.random() * (ASTEROID_MAXAGE * FRAMERATE)) + 2;
    }
    this.original_radius = this.radius;
    this.just_started_evolving = true;
    this.framesTilEvolutionActual = null;
    this.speedX = (Math.random() - 0.5) * 2.0 * ASTEROID_SPEED * speed_multiplier;
    this.speedY = (Math.random() - 0.5) * 2.0 * ASTEROID_SPEED * speed_multiplier;
    this.moveAngle = (Math.random() - 0.5) * 2.0 * ASTEROID_ROTATE_SPEED * speed_multiplier;

    this.spoke_angle_offsets = [];
    this.spoke_radii_offsets = [];
    for (let i = 0; i < ASTEROID_NUM_POINTS; i++) {
      this.spoke_angle_offsets.push((Math.random() - 0.5) * 2.0 * angle_incr / 2);
      this.spoke_radii_offsets.push((Math.random() - 0.5) * 2.0 * 1.0 / 2);
    }
  }

  update () {

    this.spoke_angles = [];
    this.spoke_radii = [];
    this.polygon_x = [];
    this.polygon_y = [];
    var angle = 0;
    
    for (let i = 0; i < ASTEROID_NUM_POINTS; i++) {
      this.spoke_angles.push(this.angle + (angle_incr * i) + this.spoke_angle_offsets[i]);
      this.spoke_radii.push(this.radius + (this.spoke_radii_offsets[i] * this.radius));
      this.polygon_x.push(this.spoke_radii[i] * Math.cos(this.spoke_angles[i]));
      this.polygon_y.push(this.spoke_radii[i] * Math.sin(this.spoke_angles[i]));
    }

    // Draw asteroid
    var ctx = myGameArea.context;
    ctx.beginPath();
    ctx.moveTo(this.x + this.polygon_x[0], this.y + this.polygon_y[0]);
    for (let i = 1; i < ASTEROID_NUM_POINTS; i++) {
      ctx.lineTo(this.x + this.polygon_x[i], this.y + this.polygon_y[i]);
    }
    ctx.lineTo(this.x + this.polygon_x[0], this.y + this.polygon_y[0]);
    ctx.stroke();

    // Evolve if ready
    if (this.state != "LARGE") {
      this.framesTilEvolution--;
      if (this.framesTilEvolution <= 0) {
        if (this.just_started_evolving) {
          this.just_started_evolving = false;
          this.framesTilEvolutionActual = ASTEROID_EVOLUTION_TIMER * FRAMERATE;
        }
        this.framesTilEvolutionActual--;
        this.radius += 0.5;
        var new_radius = LARGE_ASTEROID_RADIUS;
        if (this.state == "SMALL") {
          new_radius = MEDIUM_ASTEROID_RADIUS;
        }
        if (this.radius > new_radius) {
          this.radius = this.original_radius;
        }
        if (this.framesTilEvolutionActual <= 0) {
          if (this.state == "SMALL") {
            this.state = "MEDIUM";  
            this.radius = MEDIUM_ASTEROID_RADIUS;
            this.original_radius = MEDIUM_ASTEROID_RADIUS;
            this.speedX /= (SMALL_ASTEROID_SPEED_MULTIPLIER/MEDIUM_ASTEROID_SPEED_MULTIPLIER);
            this.speedY /= (SMALL_ASTEROID_SPEED_MULTIPLIER/MEDIUM_ASTEROID_SPEED_MULTIPLIER);
            this.framesTilEvolution = (Math.random() * (ASTEROID_MAXAGE * FRAMERATE)) + 2;
            this.just_started_evolving = true;
          } else {
            this.state = "LARGE";
            this.radius = LARGE_ASTEROID_RADIUS;
            this.original_radius = LARGE_ASTEROID_RADIUS;
            this.speedX /= (MEDIUM_ASTEROID_SPEED_MULTIPLIER/1.0);
            this.speedY /= (MEDIUM_ASTEROID_SPEED_MULTIPLIER/1.0);
          }
        }
      }
    }
  }
}

// Missile class
class Missile extends MovingObject {
  constructor(x, y, angle, speedX, speedY, missile_index) {
    super(x, y);
    var angleCos = Math.cos(angle);
    var angleSin = Math.sin(angle);
    this.speedX = (MISSILE_SPEED * angleCos);
    this.speedY = (MISSILE_SPEED * angleSin);
    this.trailOffsetX = MISSILE_LENGTH * angleCos;
    this.trailOffsetY = MISSILE_LENGTH * angleSin;
    this.missile_index = missile_index;
    this.framesTilDeath = MISSILE_LIFESPAN;
  }
  update() {

    // Draw missile
    var ctx = myGameArea.context;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + this.trailOffsetX, this.y + this.trailOffsetY);
    ctx.stroke();

    // Delete missile if older than it's lifespan
    this.framesTilDeath--;
    if (this.framesTilDeath <= 0) {
      for (let i = this.missile_index + 1; i < missiles.length; i++) {
        missiles[i].missile_index--;
      }
      delete missiles[this.missile_index];
      missiles.splice(this.missile_index, 1);
    }

  }
}

// Player spaceship class
class Ship extends MovingObject {

  constructor(x, y) {
    super(x, y);
  }
  update() {

    // Draw spaceship
    var ctx = myGameArea.context;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    // ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(10, 15);
    ctx.lineTo(0, -15);
    ctx.lineTo(-10, 15);
    ctx.moveTo(7, 7.5);
    ctx.lineTo(-7, 7.5);
    ctx.stroke();

    ctx.restore();
  }
}

// Update per frame function
function updateGameArea() {
  myGameArea.clear();
  ship.moveAngle = 0;

  // Game control listeners
  if (myGameArea.keys && myGameArea.keys[37]) {ship.moveAngle = -SHIP_TURN_SPEED * Math.PI / 180}
  if (myGameArea.keys && myGameArea.keys[39]) {ship.moveAngle = SHIP_TURN_SPEED * Math.PI / 180}
  if (myGameArea.keys && myGameArea.keys[38]) {
    ship.speedX += SHIP_SPEED * Math.cos(ship.angle - (Math.PI / 2));
    ship.speedY += SHIP_SPEED * Math.sin(ship.angle - (Math.PI / 2));
  }

  // Missile fire event listener
  if (myGameArea.keys && (myGameArea.keys[32] || myGameArea.keys[90])) {
    if (!firing) {
      firing = true;
      missiles.push(new Missile(ship.x, ship.y, ship.angle - Math.PI / 2,
        ship.speedX, ship.speedY, missiles.length));
    }
  } else {
    firing = false;
  }

  // Update object positions and call update function
  for (let i = 0; i < missiles.length; i++) {
    missiles[i].newPos();
    var mlen = missiles.length;
    missiles[i].update();
    if (mlen != missiles.length) { // Missile was deleted; adjust index
      i--;
    }
  }
  for (let i = 0; i < asteroids.length; i++) {
    asteroids[i].newPos();
    var alen = asteroids.length;
    asteroids[i].update();
    if (alen != asteroids.length) { // Asteroid was deleted; adjust index
      i--;
    }
  }
  ship.newPos();
  ship.update();
}


function distance(x1, y1, x2, y2) {
  return Math.sqrt(((x1 - x2) ** 2) + ((y1 - y2) ** 2));
}


</script>

<!-- </center> -->
</body>
</html>